"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exceptionListFilterSelectorKeywords = exports.exceptionListFilter = void 0;
/**
 * Filter a11y violations from axe based on given {@link ExceptionList}
 * @param violations - List of violations found with axe
 * @param exceptionList - {@link ExceptionList} of map of rule to corresponding css targets that needs to be filtered from a11y results
 */
function exceptionListFilter(violations, exceptionList = {}) {
    const exceptionRules = Object.keys(exceptionList);
    if (exceptionRules.length === 0)
        return violations;
    const filteredViolations = [];
    for (const violation of violations) {
        if (!exceptionRules.includes(violation.id)) {
            filteredViolations.push(violation);
        }
        else {
            for (const result of violation.nodes) {
                const filteredResults = [];
                result.target.forEach((cssSelectorItem) => {
                    if (Array.isArray(cssSelectorItem)) {
                        cssSelectorItem.forEach((cssSelector) => {
                            if (!exceptionList[violation.id].includes(cssSelector)) {
                                filteredResults.push(cssSelector);
                            }
                        });
                    }
                    else {
                        if (!exceptionList[violation.id].includes(cssSelectorItem)) {
                            filteredResults.push(cssSelectorItem);
                        }
                    }
                });
                if (filteredResults.length > 0) {
                    filteredViolations.push(violation);
                }
            }
        }
    }
    return filteredViolations;
}
exports.exceptionListFilter = exceptionListFilter;
/**
 * Filter a11y violations from axe based on given selectors filter keywords
 * @param violations - List of violations found with axe
 * @param selectorFilterKeywords - List of selector keywords to filter violations for
 */
function exceptionListFilterSelectorKeywords(violations, selectorFilterKeywords) {
    const filteredViolations = [];
    for (const violation of violations) {
        const filteredNodes = [];
        for (const node of violation.nodes) {
            const isSelectorFilterKeywordsExists = checkSelectorFilterKeyWordsExists(node, selectorFilterKeywords);
            if (!isSelectorFilterKeywordsExists) {
                filteredNodes.push(node);
            }
        }
        if (filteredNodes.length > 0) {
            violation.nodes = filteredNodes;
            filteredViolations.push(violation);
        }
    }
    return filteredViolations;
}
exports.exceptionListFilterSelectorKeywords = exceptionListFilterSelectorKeywords;
function checkSelectorFilterKeyWordsExists(node, selectorFilterKeywords) {
    const selectorAncestry = (node.ancestry?.flat(Infinity) ?? []);
    let isExists = false;
    selectorFilterKeywords.some((keyword) => {
        isExists = selectorAncestry.some((selector) => {
            const lastSelector = selector.split('>').pop();
            return lastSelector.includes(keyword);
        });
        return isExists;
    });
    return isExists;
}
//# sourceMappingURL=filter.js.map