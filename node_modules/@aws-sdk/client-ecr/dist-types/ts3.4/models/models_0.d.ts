import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ECRServiceException as __BaseException } from "./ECRServiceException";
export interface BatchCheckLayerAvailabilityRequest {
  registryId?: string;
  repositoryName: string | undefined;
  layerDigests: string[] | undefined;
}
export declare const LayerFailureCode: {
  readonly InvalidLayerDigest: "InvalidLayerDigest";
  readonly MissingLayerDigest: "MissingLayerDigest";
};
export type LayerFailureCode =
  (typeof LayerFailureCode)[keyof typeof LayerFailureCode];
export interface LayerFailure {
  layerDigest?: string;
  failureCode?: LayerFailureCode;
  failureReason?: string;
}
export declare const LayerAvailability: {
  readonly AVAILABLE: "AVAILABLE";
  readonly UNAVAILABLE: "UNAVAILABLE";
};
export type LayerAvailability =
  (typeof LayerAvailability)[keyof typeof LayerAvailability];
export interface Layer {
  layerDigest?: string;
  layerAvailability?: LayerAvailability;
  layerSize?: number;
  mediaType?: string;
}
export interface BatchCheckLayerAvailabilityResponse {
  layers?: Layer[];
  failures?: LayerFailure[];
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class RepositoryNotFoundException extends __BaseException {
  readonly name: "RepositoryNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RepositoryNotFoundException, __BaseException>
  );
}
export declare class ServerException extends __BaseException {
  readonly name: "ServerException";
  readonly $fault: "server";
  constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
export interface ImageIdentifier {
  imageDigest?: string;
  imageTag?: string;
}
export interface BatchDeleteImageRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds: ImageIdentifier[] | undefined;
}
export declare const ImageFailureCode: {
  readonly ImageNotFound: "ImageNotFound";
  readonly ImageReferencedByManifestList: "ImageReferencedByManifestList";
  readonly ImageTagDoesNotMatchDigest: "ImageTagDoesNotMatchDigest";
  readonly InvalidImageDigest: "InvalidImageDigest";
  readonly InvalidImageTag: "InvalidImageTag";
  readonly KmsError: "KmsError";
  readonly MissingDigestAndTag: "MissingDigestAndTag";
  readonly UpstreamAccessDenied: "UpstreamAccessDenied";
  readonly UpstreamTooManyRequests: "UpstreamTooManyRequests";
  readonly UpstreamUnavailable: "UpstreamUnavailable";
};
export type ImageFailureCode =
  (typeof ImageFailureCode)[keyof typeof ImageFailureCode];
export interface ImageFailure {
  imageId?: ImageIdentifier;
  failureCode?: ImageFailureCode;
  failureReason?: string;
}
export interface BatchDeleteImageResponse {
  imageIds?: ImageIdentifier[];
  failures?: ImageFailure[];
}
export interface BatchGetImageRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds: ImageIdentifier[] | undefined;
  acceptedMediaTypes?: string[];
}
export interface Image {
  registryId?: string;
  repositoryName?: string;
  imageId?: ImageIdentifier;
  imageManifest?: string;
  imageManifestMediaType?: string;
}
export interface BatchGetImageResponse {
  images?: Image[];
  failures?: ImageFailure[];
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export declare class UnableToGetUpstreamImageException extends __BaseException {
  readonly name: "UnableToGetUpstreamImageException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnableToGetUpstreamImageException,
      __BaseException
    >
  );
}
export interface BatchGetRepositoryScanningConfigurationRequest {
  repositoryNames: string[] | undefined;
}
export declare const ScanningConfigurationFailureCode: {
  readonly REPOSITORY_NOT_FOUND: "REPOSITORY_NOT_FOUND";
};
export type ScanningConfigurationFailureCode =
  (typeof ScanningConfigurationFailureCode)[keyof typeof ScanningConfigurationFailureCode];
export interface RepositoryScanningConfigurationFailure {
  repositoryName?: string;
  failureCode?: ScanningConfigurationFailureCode;
  failureReason?: string;
}
export declare const ScanningRepositoryFilterType: {
  readonly WILDCARD: "WILDCARD";
};
export type ScanningRepositoryFilterType =
  (typeof ScanningRepositoryFilterType)[keyof typeof ScanningRepositoryFilterType];
export interface ScanningRepositoryFilter {
  filter: string | undefined;
  filterType: ScanningRepositoryFilterType | undefined;
}
export declare const ScanFrequency: {
  readonly CONTINUOUS_SCAN: "CONTINUOUS_SCAN";
  readonly MANUAL: "MANUAL";
  readonly SCAN_ON_PUSH: "SCAN_ON_PUSH";
};
export type ScanFrequency = (typeof ScanFrequency)[keyof typeof ScanFrequency];
export interface RepositoryScanningConfiguration {
  repositoryArn?: string;
  repositoryName?: string;
  scanOnPush?: boolean;
  scanFrequency?: ScanFrequency;
  appliedScanFilters?: ScanningRepositoryFilter[];
}
export interface BatchGetRepositoryScanningConfigurationResponse {
  scanningConfigurations?: RepositoryScanningConfiguration[];
  failures?: RepositoryScanningConfigurationFailure[];
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface CompleteLayerUploadRequest {
  registryId?: string;
  repositoryName: string | undefined;
  uploadId: string | undefined;
  layerDigests: string[] | undefined;
}
export interface CompleteLayerUploadResponse {
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  layerDigest?: string;
}
export declare class EmptyUploadException extends __BaseException {
  readonly name: "EmptyUploadException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EmptyUploadException, __BaseException>
  );
}
export declare class InvalidLayerException extends __BaseException {
  readonly name: "InvalidLayerException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidLayerException, __BaseException>
  );
}
export declare class KmsException extends __BaseException {
  readonly name: "KmsException";
  readonly $fault: "client";
  kmsError?: string;
  constructor(opts: __ExceptionOptionType<KmsException, __BaseException>);
}
export declare class LayerAlreadyExistsException extends __BaseException {
  readonly name: "LayerAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayerAlreadyExistsException, __BaseException>
  );
}
export declare class LayerPartTooSmallException extends __BaseException {
  readonly name: "LayerPartTooSmallException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayerPartTooSmallException, __BaseException>
  );
}
export declare class UploadNotFoundException extends __BaseException {
  readonly name: "UploadNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UploadNotFoundException, __BaseException>
  );
}
export declare const UpstreamRegistry: {
  readonly AzureContainerRegistry: "azure-container-registry";
  readonly DockerHub: "docker-hub";
  readonly EcrPublic: "ecr-public";
  readonly GitHubContainerRegistry: "github-container-registry";
  readonly GitLabContainerRegistry: "gitlab-container-registry";
  readonly K8s: "k8s";
  readonly Quay: "quay";
};
export type UpstreamRegistry =
  (typeof UpstreamRegistry)[keyof typeof UpstreamRegistry];
export interface CreatePullThroughCacheRuleRequest {
  ecrRepositoryPrefix: string | undefined;
  upstreamRegistryUrl: string | undefined;
  registryId?: string;
  upstreamRegistry?: UpstreamRegistry;
  credentialArn?: string;
}
export interface CreatePullThroughCacheRuleResponse {
  ecrRepositoryPrefix?: string;
  upstreamRegistryUrl?: string;
  createdAt?: Date;
  registryId?: string;
  upstreamRegistry?: UpstreamRegistry;
  credentialArn?: string;
}
export declare class PullThroughCacheRuleAlreadyExistsException extends __BaseException {
  readonly name: "PullThroughCacheRuleAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      PullThroughCacheRuleAlreadyExistsException,
      __BaseException
    >
  );
}
export declare class SecretNotFoundException extends __BaseException {
  readonly name: "SecretNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SecretNotFoundException, __BaseException>
  );
}
export declare class UnableToAccessSecretException extends __BaseException {
  readonly name: "UnableToAccessSecretException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnableToAccessSecretException, __BaseException>
  );
}
export declare class UnableToDecryptSecretValueException extends __BaseException {
  readonly name: "UnableToDecryptSecretValueException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnableToDecryptSecretValueException,
      __BaseException
    >
  );
}
export declare class UnsupportedUpstreamRegistryException extends __BaseException {
  readonly name: "UnsupportedUpstreamRegistryException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedUpstreamRegistryException,
      __BaseException
    >
  );
}
export declare const EncryptionType: {
  readonly AES256: "AES256";
  readonly KMS: "KMS";
};
export type EncryptionType =
  (typeof EncryptionType)[keyof typeof EncryptionType];
export interface EncryptionConfiguration {
  encryptionType: EncryptionType | undefined;
  kmsKey?: string;
}
export interface ImageScanningConfiguration {
  scanOnPush?: boolean;
}
export declare const ImageTagMutability: {
  readonly IMMUTABLE: "IMMUTABLE";
  readonly MUTABLE: "MUTABLE";
};
export type ImageTagMutability =
  (typeof ImageTagMutability)[keyof typeof ImageTagMutability];
export interface Tag {
  Key: string | undefined;
  Value: string | undefined;
}
export interface CreateRepositoryRequest {
  registryId?: string;
  repositoryName: string | undefined;
  tags?: Tag[];
  imageTagMutability?: ImageTagMutability;
  imageScanningConfiguration?: ImageScanningConfiguration;
  encryptionConfiguration?: EncryptionConfiguration;
}
export interface Repository {
  repositoryArn?: string;
  registryId?: string;
  repositoryName?: string;
  repositoryUri?: string;
  createdAt?: Date;
  imageTagMutability?: ImageTagMutability;
  imageScanningConfiguration?: ImageScanningConfiguration;
  encryptionConfiguration?: EncryptionConfiguration;
}
export interface CreateRepositoryResponse {
  repository?: Repository;
}
export declare class InvalidTagParameterException extends __BaseException {
  readonly name: "InvalidTagParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTagParameterException, __BaseException>
  );
}
export declare class RepositoryAlreadyExistsException extends __BaseException {
  readonly name: "RepositoryAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RepositoryAlreadyExistsException,
      __BaseException
    >
  );
}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export declare const RCTAppliedFor: {
  readonly PULL_THROUGH_CACHE: "PULL_THROUGH_CACHE";
  readonly REPLICATION: "REPLICATION";
};
export type RCTAppliedFor = (typeof RCTAppliedFor)[keyof typeof RCTAppliedFor];
export interface EncryptionConfigurationForRepositoryCreationTemplate {
  encryptionType: EncryptionType | undefined;
  kmsKey?: string;
}
export interface CreateRepositoryCreationTemplateRequest {
  prefix: string | undefined;
  description?: string;
  encryptionConfiguration?: EncryptionConfigurationForRepositoryCreationTemplate;
  resourceTags?: Tag[];
  imageTagMutability?: ImageTagMutability;
  repositoryPolicy?: string;
  lifecyclePolicy?: string;
  appliedFor: RCTAppliedFor[] | undefined;
  customRoleArn?: string;
}
export interface RepositoryCreationTemplate {
  prefix?: string;
  description?: string;
  encryptionConfiguration?: EncryptionConfigurationForRepositoryCreationTemplate;
  resourceTags?: Tag[];
  imageTagMutability?: ImageTagMutability;
  repositoryPolicy?: string;
  lifecyclePolicy?: string;
  appliedFor?: RCTAppliedFor[];
  customRoleArn?: string;
  createdAt?: Date;
  updatedAt?: Date;
}
export interface CreateRepositoryCreationTemplateResponse {
  registryId?: string;
  repositoryCreationTemplate?: RepositoryCreationTemplate;
}
export declare class TemplateAlreadyExistsException extends __BaseException {
  readonly name: "TemplateAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TemplateAlreadyExistsException, __BaseException>
  );
}
export interface DeleteLifecyclePolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface DeleteLifecyclePolicyResponse {
  registryId?: string;
  repositoryName?: string;
  lifecyclePolicyText?: string;
  lastEvaluatedAt?: Date;
}
export declare class LifecyclePolicyNotFoundException extends __BaseException {
  readonly name: "LifecyclePolicyNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      LifecyclePolicyNotFoundException,
      __BaseException
    >
  );
}
export interface DeletePullThroughCacheRuleRequest {
  ecrRepositoryPrefix: string | undefined;
  registryId?: string;
}
export interface DeletePullThroughCacheRuleResponse {
  ecrRepositoryPrefix?: string;
  upstreamRegistryUrl?: string;
  createdAt?: Date;
  registryId?: string;
  credentialArn?: string;
}
export declare class PullThroughCacheRuleNotFoundException extends __BaseException {
  readonly name: "PullThroughCacheRuleNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      PullThroughCacheRuleNotFoundException,
      __BaseException
    >
  );
}
export interface DeleteRegistryPolicyRequest {}
export interface DeleteRegistryPolicyResponse {
  registryId?: string;
  policyText?: string;
}
export declare class RegistryPolicyNotFoundException extends __BaseException {
  readonly name: "RegistryPolicyNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RegistryPolicyNotFoundException,
      __BaseException
    >
  );
}
export interface DeleteRepositoryRequest {
  registryId?: string;
  repositoryName: string | undefined;
  force?: boolean;
}
export interface DeleteRepositoryResponse {
  repository?: Repository;
}
export declare class RepositoryNotEmptyException extends __BaseException {
  readonly name: "RepositoryNotEmptyException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RepositoryNotEmptyException, __BaseException>
  );
}
export interface DeleteRepositoryCreationTemplateRequest {
  prefix: string | undefined;
}
export interface DeleteRepositoryCreationTemplateResponse {
  registryId?: string;
  repositoryCreationTemplate?: RepositoryCreationTemplate;
}
export declare class TemplateNotFoundException extends __BaseException {
  readonly name: "TemplateNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TemplateNotFoundException, __BaseException>
  );
}
export interface DeleteRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface DeleteRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export declare class RepositoryPolicyNotFoundException extends __BaseException {
  readonly name: "RepositoryPolicyNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RepositoryPolicyNotFoundException,
      __BaseException
    >
  );
}
export interface DescribeImageReplicationStatusRequest {
  repositoryName: string | undefined;
  imageId: ImageIdentifier | undefined;
  registryId?: string;
}
export declare const ReplicationStatus: {
  readonly COMPLETE: "COMPLETE";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
};
export type ReplicationStatus =
  (typeof ReplicationStatus)[keyof typeof ReplicationStatus];
export interface ImageReplicationStatus {
  region?: string;
  registryId?: string;
  status?: ReplicationStatus;
  failureCode?: string;
}
export interface DescribeImageReplicationStatusResponse {
  repositoryName?: string;
  imageId?: ImageIdentifier;
  replicationStatuses?: ImageReplicationStatus[];
}
export declare class ImageNotFoundException extends __BaseException {
  readonly name: "ImageNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageNotFoundException, __BaseException>
  );
}
export declare const TagStatus: {
  readonly ANY: "ANY";
  readonly TAGGED: "TAGGED";
  readonly UNTAGGED: "UNTAGGED";
};
export type TagStatus = (typeof TagStatus)[keyof typeof TagStatus];
export interface DescribeImagesFilter {
  tagStatus?: TagStatus;
}
export interface DescribeImagesRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds?: ImageIdentifier[];
  nextToken?: string;
  maxResults?: number;
  filter?: DescribeImagesFilter;
}
export declare const FindingSeverity: {
  readonly CRITICAL: "CRITICAL";
  readonly HIGH: "HIGH";
  readonly INFORMATIONAL: "INFORMATIONAL";
  readonly LOW: "LOW";
  readonly MEDIUM: "MEDIUM";
  readonly UNDEFINED: "UNDEFINED";
};
export type FindingSeverity =
  (typeof FindingSeverity)[keyof typeof FindingSeverity];
export interface ImageScanFindingsSummary {
  imageScanCompletedAt?: Date;
  vulnerabilitySourceUpdatedAt?: Date;
  findingSeverityCounts?: Partial<Record<FindingSeverity, number>>;
}
export declare const ScanStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly COMPLETE: "COMPLETE";
  readonly FAILED: "FAILED";
  readonly FINDINGS_UNAVAILABLE: "FINDINGS_UNAVAILABLE";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly PENDING: "PENDING";
  readonly SCAN_ELIGIBILITY_EXPIRED: "SCAN_ELIGIBILITY_EXPIRED";
  readonly UNSUPPORTED_IMAGE: "UNSUPPORTED_IMAGE";
};
export type ScanStatus = (typeof ScanStatus)[keyof typeof ScanStatus];
export interface ImageScanStatus {
  status?: ScanStatus;
  description?: string;
}
export interface ImageDetail {
  registryId?: string;
  repositoryName?: string;
  imageDigest?: string;
  imageTags?: string[];
  imageSizeInBytes?: number;
  imagePushedAt?: Date;
  imageScanStatus?: ImageScanStatus;
  imageScanFindingsSummary?: ImageScanFindingsSummary;
  imageManifestMediaType?: string;
  artifactMediaType?: string;
  lastRecordedPullTime?: Date;
}
export interface DescribeImagesResponse {
  imageDetails?: ImageDetail[];
  nextToken?: string;
}
export interface DescribeImageScanFindingsRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageId: ImageIdentifier | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface CvssScore {
  baseScore?: number;
  scoringVector?: string;
  source?: string;
  version?: string;
}
export interface VulnerablePackage {
  arch?: string;
  epoch?: number;
  filePath?: string;
  name?: string;
  packageManager?: string;
  release?: string;
  sourceLayerHash?: string;
  version?: string;
}
export interface PackageVulnerabilityDetails {
  cvss?: CvssScore[];
  referenceUrls?: string[];
  relatedVulnerabilities?: string[];
  source?: string;
  sourceUrl?: string;
  vendorCreatedAt?: Date;
  vendorSeverity?: string;
  vendorUpdatedAt?: Date;
  vulnerabilityId?: string;
  vulnerablePackages?: VulnerablePackage[];
}
export interface Recommendation {
  url?: string;
  text?: string;
}
export interface Remediation {
  recommendation?: Recommendation;
}
export interface AwsEcrContainerImageDetails {
  architecture?: string;
  author?: string;
  imageHash?: string;
  imageTags?: string[];
  platform?: string;
  pushedAt?: Date;
  registry?: string;
  repositoryName?: string;
}
export interface ResourceDetails {
  awsEcrContainerImage?: AwsEcrContainerImageDetails;
}
export interface Resource {
  details?: ResourceDetails;
  id?: string;
  tags?: Record<string, string>;
  type?: string;
}
export interface CvssScoreAdjustment {
  metric?: string;
  reason?: string;
}
export interface CvssScoreDetails {
  adjustments?: CvssScoreAdjustment[];
  score?: number;
  scoreSource?: string;
  scoringVector?: string;
  version?: string;
}
export interface ScoreDetails {
  cvss?: CvssScoreDetails;
}
export interface EnhancedImageScanFinding {
  awsAccountId?: string;
  description?: string;
  findingArn?: string;
  firstObservedAt?: Date;
  lastObservedAt?: Date;
  packageVulnerabilityDetails?: PackageVulnerabilityDetails;
  remediation?: Remediation;
  resources?: Resource[];
  score?: number;
  scoreDetails?: ScoreDetails;
  severity?: string;
  status?: string;
  title?: string;
  type?: string;
  updatedAt?: Date;
}
export interface Attribute {
  key: string | undefined;
  value?: string;
}
export interface ImageScanFinding {
  name?: string;
  description?: string;
  uri?: string;
  severity?: FindingSeverity;
  attributes?: Attribute[];
}
export interface ImageScanFindings {
  imageScanCompletedAt?: Date;
  vulnerabilitySourceUpdatedAt?: Date;
  findingSeverityCounts?: Partial<Record<FindingSeverity, number>>;
  findings?: ImageScanFinding[];
  enhancedFindings?: EnhancedImageScanFinding[];
}
export interface DescribeImageScanFindingsResponse {
  registryId?: string;
  repositoryName?: string;
  imageId?: ImageIdentifier;
  imageScanStatus?: ImageScanStatus;
  imageScanFindings?: ImageScanFindings;
  nextToken?: string;
}
export declare class ScanNotFoundException extends __BaseException {
  readonly name: "ScanNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ScanNotFoundException, __BaseException>
  );
}
export interface DescribePullThroughCacheRulesRequest {
  registryId?: string;
  ecrRepositoryPrefixes?: string[];
  nextToken?: string;
  maxResults?: number;
}
export interface PullThroughCacheRule {
  ecrRepositoryPrefix?: string;
  upstreamRegistryUrl?: string;
  createdAt?: Date;
  registryId?: string;
  credentialArn?: string;
  upstreamRegistry?: UpstreamRegistry;
  updatedAt?: Date;
}
export interface DescribePullThroughCacheRulesResponse {
  pullThroughCacheRules?: PullThroughCacheRule[];
  nextToken?: string;
}
export interface DescribeRegistryRequest {}
export interface ReplicationDestination {
  region: string | undefined;
  registryId: string | undefined;
}
export declare const RepositoryFilterType: {
  readonly PREFIX_MATCH: "PREFIX_MATCH";
};
export type RepositoryFilterType =
  (typeof RepositoryFilterType)[keyof typeof RepositoryFilterType];
export interface RepositoryFilter {
  filter: string | undefined;
  filterType: RepositoryFilterType | undefined;
}
export interface ReplicationRule {
  destinations: ReplicationDestination[] | undefined;
  repositoryFilters?: RepositoryFilter[];
}
export interface ReplicationConfiguration {
  rules: ReplicationRule[] | undefined;
}
export interface DescribeRegistryResponse {
  registryId?: string;
  replicationConfiguration?: ReplicationConfiguration;
}
export interface DescribeRepositoriesRequest {
  registryId?: string;
  repositoryNames?: string[];
  nextToken?: string;
  maxResults?: number;
}
export interface DescribeRepositoriesResponse {
  repositories?: Repository[];
  nextToken?: string;
}
export interface DescribeRepositoryCreationTemplatesRequest {
  prefixes?: string[];
  nextToken?: string;
  maxResults?: number;
}
export interface DescribeRepositoryCreationTemplatesResponse {
  registryId?: string;
  repositoryCreationTemplates?: RepositoryCreationTemplate[];
  nextToken?: string;
}
export interface GetAccountSettingRequest {
  name: string | undefined;
}
export interface GetAccountSettingResponse {
  name?: string;
  value?: string;
}
export interface GetAuthorizationTokenRequest {
  registryIds?: string[];
}
export interface AuthorizationData {
  authorizationToken?: string;
  expiresAt?: Date;
  proxyEndpoint?: string;
}
export interface GetAuthorizationTokenResponse {
  authorizationData?: AuthorizationData[];
}
export interface GetDownloadUrlForLayerRequest {
  registryId?: string;
  repositoryName: string | undefined;
  layerDigest: string | undefined;
}
export interface GetDownloadUrlForLayerResponse {
  downloadUrl?: string;
  layerDigest?: string;
}
export declare class LayerInaccessibleException extends __BaseException {
  readonly name: "LayerInaccessibleException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayerInaccessibleException, __BaseException>
  );
}
export declare class LayersNotFoundException extends __BaseException {
  readonly name: "LayersNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayersNotFoundException, __BaseException>
  );
}
export declare class UnableToGetUpstreamLayerException extends __BaseException {
  readonly name: "UnableToGetUpstreamLayerException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnableToGetUpstreamLayerException,
      __BaseException
    >
  );
}
export interface GetLifecyclePolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface GetLifecyclePolicyResponse {
  registryId?: string;
  repositoryName?: string;
  lifecyclePolicyText?: string;
  lastEvaluatedAt?: Date;
}
export interface LifecyclePolicyPreviewFilter {
  tagStatus?: TagStatus;
}
export interface GetLifecyclePolicyPreviewRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds?: ImageIdentifier[];
  nextToken?: string;
  maxResults?: number;
  filter?: LifecyclePolicyPreviewFilter;
}
export declare const ImageActionType: {
  readonly EXPIRE: "EXPIRE";
};
export type ImageActionType =
  (typeof ImageActionType)[keyof typeof ImageActionType];
export interface LifecyclePolicyRuleAction {
  type?: ImageActionType;
}
export interface LifecyclePolicyPreviewResult {
  imageTags?: string[];
  imageDigest?: string;
  imagePushedAt?: Date;
  action?: LifecyclePolicyRuleAction;
  appliedRulePriority?: number;
}
export declare const LifecyclePolicyPreviewStatus: {
  readonly COMPLETE: "COMPLETE";
  readonly EXPIRED: "EXPIRED";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
};
export type LifecyclePolicyPreviewStatus =
  (typeof LifecyclePolicyPreviewStatus)[keyof typeof LifecyclePolicyPreviewStatus];
export interface LifecyclePolicyPreviewSummary {
  expiringImageTotalCount?: number;
}
export interface GetLifecyclePolicyPreviewResponse {
  registryId?: string;
  repositoryName?: string;
  lifecyclePolicyText?: string;
  status?: LifecyclePolicyPreviewStatus;
  nextToken?: string;
  previewResults?: LifecyclePolicyPreviewResult[];
  summary?: LifecyclePolicyPreviewSummary;
}
export declare class LifecyclePolicyPreviewNotFoundException extends __BaseException {
  readonly name: "LifecyclePolicyPreviewNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      LifecyclePolicyPreviewNotFoundException,
      __BaseException
    >
  );
}
export interface GetRegistryPolicyRequest {}
export interface GetRegistryPolicyResponse {
  registryId?: string;
  policyText?: string;
}
export interface GetRegistryScanningConfigurationRequest {}
export interface RegistryScanningRule {
  scanFrequency: ScanFrequency | undefined;
  repositoryFilters: ScanningRepositoryFilter[] | undefined;
}
export declare const ScanType: {
  readonly BASIC: "BASIC";
  readonly ENHANCED: "ENHANCED";
};
export type ScanType = (typeof ScanType)[keyof typeof ScanType];
export interface RegistryScanningConfiguration {
  scanType?: ScanType;
  rules?: RegistryScanningRule[];
}
export interface GetRegistryScanningConfigurationResponse {
  registryId?: string;
  scanningConfiguration?: RegistryScanningConfiguration;
}
export interface GetRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface GetRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export interface InitiateLayerUploadRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface InitiateLayerUploadResponse {
  uploadId?: string;
  partSize?: number;
}
export interface ListImagesFilter {
  tagStatus?: TagStatus;
}
export interface ListImagesRequest {
  registryId?: string;
  repositoryName: string | undefined;
  nextToken?: string;
  maxResults?: number;
  filter?: ListImagesFilter;
}
export interface ListImagesResponse {
  imageIds?: ImageIdentifier[];
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Tag[];
}
export interface PutAccountSettingRequest {
  name: string | undefined;
  value: string | undefined;
}
export interface PutAccountSettingResponse {
  name?: string;
  value?: string;
}
export declare class ImageAlreadyExistsException extends __BaseException {
  readonly name: "ImageAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageAlreadyExistsException, __BaseException>
  );
}
export declare class ImageDigestDoesNotMatchException extends __BaseException {
  readonly name: "ImageDigestDoesNotMatchException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ImageDigestDoesNotMatchException,
      __BaseException
    >
  );
}
export declare class ImageTagAlreadyExistsException extends __BaseException {
  readonly name: "ImageTagAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageTagAlreadyExistsException, __BaseException>
  );
}
export interface PutImageRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageManifest: string | undefined;
  imageManifestMediaType?: string;
  imageTag?: string;
  imageDigest?: string;
}
export interface PutImageResponse {
  image?: Image;
}
export declare class ReferencedImagesNotFoundException extends __BaseException {
  readonly name: "ReferencedImagesNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReferencedImagesNotFoundException,
      __BaseException
    >
  );
}
export interface PutImageScanningConfigurationRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageScanningConfiguration: ImageScanningConfiguration | undefined;
}
export interface PutImageScanningConfigurationResponse {
  registryId?: string;
  repositoryName?: string;
  imageScanningConfiguration?: ImageScanningConfiguration;
}
export interface PutImageTagMutabilityRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageTagMutability: ImageTagMutability | undefined;
}
export interface PutImageTagMutabilityResponse {
  registryId?: string;
  repositoryName?: string;
  imageTagMutability?: ImageTagMutability;
}
export interface PutLifecyclePolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
  lifecyclePolicyText: string | undefined;
}
export interface PutLifecyclePolicyResponse {
  registryId?: string;
  repositoryName?: string;
  lifecyclePolicyText?: string;
}
export interface PutRegistryPolicyRequest {
  policyText: string | undefined;
}
export interface PutRegistryPolicyResponse {
  registryId?: string;
  policyText?: string;
}
export interface PutRegistryScanningConfigurationRequest {
  scanType?: ScanType;
  rules?: RegistryScanningRule[];
}
export interface PutRegistryScanningConfigurationResponse {
  registryScanningConfiguration?: RegistryScanningConfiguration;
}
export interface PutReplicationConfigurationRequest {
  replicationConfiguration: ReplicationConfiguration | undefined;
}
export interface PutReplicationConfigurationResponse {
  replicationConfiguration?: ReplicationConfiguration;
}
export interface SetRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
  policyText: string | undefined;
  force?: boolean;
}
export interface SetRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export interface StartImageScanRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageId: ImageIdentifier | undefined;
}
export interface StartImageScanResponse {
  registryId?: string;
  repositoryName?: string;
  imageId?: ImageIdentifier;
  imageScanStatus?: ImageScanStatus;
}
export declare class UnsupportedImageTypeException extends __BaseException {
  readonly name: "UnsupportedImageTypeException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnsupportedImageTypeException, __BaseException>
  );
}
export declare class LifecyclePolicyPreviewInProgressException extends __BaseException {
  readonly name: "LifecyclePolicyPreviewInProgressException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      LifecyclePolicyPreviewInProgressException,
      __BaseException
    >
  );
}
export interface StartLifecyclePolicyPreviewRequest {
  registryId?: string;
  repositoryName: string | undefined;
  lifecyclePolicyText?: string;
}
export interface StartLifecyclePolicyPreviewResponse {
  registryId?: string;
  repositoryName?: string;
  lifecyclePolicyText?: string;
  status?: LifecyclePolicyPreviewStatus;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Tag[] | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface UpdatePullThroughCacheRuleRequest {
  registryId?: string;
  ecrRepositoryPrefix: string | undefined;
  credentialArn: string | undefined;
}
export interface UpdatePullThroughCacheRuleResponse {
  ecrRepositoryPrefix?: string;
  registryId?: string;
  updatedAt?: Date;
  credentialArn?: string;
}
export interface UpdateRepositoryCreationTemplateRequest {
  prefix: string | undefined;
  description?: string;
  encryptionConfiguration?: EncryptionConfigurationForRepositoryCreationTemplate;
  resourceTags?: Tag[];
  imageTagMutability?: ImageTagMutability;
  repositoryPolicy?: string;
  lifecyclePolicy?: string;
  appliedFor?: RCTAppliedFor[];
  customRoleArn?: string;
}
export interface UpdateRepositoryCreationTemplateResponse {
  registryId?: string;
  repositoryCreationTemplate?: RepositoryCreationTemplate;
}
export declare class InvalidLayerPartException extends __BaseException {
  readonly name: "InvalidLayerPartException";
  readonly $fault: "client";
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  lastValidByteReceived?: number;
  constructor(
    opts: __ExceptionOptionType<InvalidLayerPartException, __BaseException>
  );
}
export interface UploadLayerPartRequest {
  registryId?: string;
  repositoryName: string | undefined;
  uploadId: string | undefined;
  partFirstByte: number | undefined;
  partLastByte: number | undefined;
  layerPartBlob: Uint8Array | undefined;
}
export interface UploadLayerPartResponse {
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  lastByteReceived?: number;
}
export interface ValidatePullThroughCacheRuleRequest {
  ecrRepositoryPrefix: string | undefined;
  registryId?: string;
}
export interface ValidatePullThroughCacheRuleResponse {
  ecrRepositoryPrefix?: string;
  registryId?: string;
  upstreamRegistryUrl?: string;
  credentialArn?: string;
  isValid?: boolean;
  failure?: string;
}
