{"version":3,"file":"helpers.js","sources":["../../../../../src/integrations/tracing/nest/helpers.ts"],"sourcesContent":["import { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '@sentry/core';\nimport { addNonEnumerableProperty } from '@sentry/utils';\nimport type { CatchTarget, InjectableTarget } from './types';\n\nconst sentryPatched = 'sentryPatched';\n\n/**\n * Helper checking if a concrete target class is already patched.\n *\n * We already guard duplicate patching with isWrapped. However, isWrapped checks whether a file has been patched, whereas we use this check for concrete target classes.\n * This check might not be necessary, but better to play it safe.\n */\nexport function isPatched(target: InjectableTarget | CatchTarget): boolean {\n  if (target.sentryPatched) {\n    return true;\n  }\n\n  addNonEnumerableProperty(target, sentryPatched, true);\n  return false;\n}\n\n/**\n * Returns span options for nest middleware spans.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function getMiddlewareSpanOptions(target: InjectableTarget | CatchTarget) {\n  return {\n    name: target.name,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'middleware.nestjs',\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.middleware.nestjs',\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAIA,MAAM,aAAA,GAAgB,eAAe,CAAA;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,SAAS,CAAC,MAAM,EAA2C;AAC3E,EAAE,IAAI,MAAM,CAAC,aAAa,EAAE;AAC5B,IAAI,OAAO,IAAI,CAAA;AACf,GAAE;AACF;AACA,EAAE,wBAAwB,CAAC,MAAM,EAAE,aAAa,EAAE,IAAI,CAAC,CAAA;AACvD,EAAE,OAAO,KAAK,CAAA;AACd,CAAA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,wBAAwB,CAAC,MAAM,EAAkC;AACjF,EAAE,OAAO;AACT,IAAI,IAAI,EAAE,MAAM,CAAC,IAAI;AACrB,IAAI,UAAU,EAAE;AAChB,MAAM,CAAC,4BAA4B,GAAG,mBAAmB;AACzD,MAAM,CAAC,gCAAgC,GAAG,wBAAwB;AAClE,KAAK;AACL,GAAG,CAAA;AACH;;;;"}